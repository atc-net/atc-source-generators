// ReSharper disable ForeachCanBePartlyConvertedToQueryUsingAnotherGetEnumerator
// ReSharper disable InvertIf
namespace Atc.SourceGenerators.Generators;

/// <summary>
/// Source generator for automatic enum-to-enum mapping with intelligent name matching and special case handling.
/// </summary>
[Generator]
public class EnumMappingGenerator : IIncrementalGenerator
{
    private const string AttributeNamespace = "Atc.SourceGenerators.Annotations";
    private const string AttributeName = "MapToAttribute";
    private const string FullAttributeName = $"{AttributeNamespace}.{AttributeName}";

    private static readonly DiagnosticDescriptor TargetTypeMustBeEnumDescriptor = new(
        id: RuleIdentifierConstants.EnumMapping.TargetTypeMustBeEnum,
        title: "Target type must be an enum",
        messageFormat: "Target type '{0}' must be an enum type for enum mapping",
        category: RuleCategoryConstants.EnumMapping,
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor UnmappedEnumValueDescriptor = new(
        id: RuleIdentifierConstants.EnumMapping.UnmappedEnumValue,
        title: "Unmapped enum value",
        messageFormat: "Enum value '{0}.{1}' has no matching value in target enum '{2}'",
        category: RuleCategoryConstants.EnumMapping,
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Note: MapToAttribute is generated by ObjectMappingGenerator in PostInitialization
        // Both generators share the same attribute, so it's only emitted once

        // Find enums with MapTo attribute
        var enumDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null)
            .Collect();

        // Combine with compilation
        var compilationAndEnums = context.CompilationProvider.Combine(enumDeclarations);

        // Generate source
        context.RegisterSourceOutput(compilationAndEnums, static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        => node is EnumDeclarationSyntax { AttributeLists.Count: > 0 };

    private static EnumDeclarationSyntax? GetSemanticTargetForGeneration(
        GeneratorSyntaxContext context)
    {
        var enumDeclaration = (EnumDeclarationSyntax)context.Node;

        foreach (var attributeListSyntax in enumDeclaration.AttributeLists)
        {
            foreach (var attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                {
                    continue;
                }

                var attributeContainingTypeSymbol = attributeSymbol.ContainingType;
                var fullName = attributeContainingTypeSymbol.ToDisplayString();

                if (fullName == FullAttributeName)
                {
                    return enumDeclaration;
                }
            }
        }

        return null;
    }

    private static void Execute(
        Compilation compilation,
        ImmutableArray<EnumDeclarationSyntax> enums,
        SourceProductionContext context)
    {
        if (enums.IsDefaultOrEmpty)
        {
            return;
        }

        var mappingsToGenerate = new List<EnumMappingInfo>();

        foreach (var enumDeclaration in enums.Distinct())
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            var semanticModel = compilation.GetSemanticModel(enumDeclaration.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(enumDeclaration) is not { } enumSymbol)
            {
                continue;
            }

            var mappingInfos = ExtractMappingInfo(enumSymbol, context);
            if (mappingInfos is not null)
            {
                mappingsToGenerate.AddRange(mappingInfos);
            }
        }

        if (mappingsToGenerate.Count == 0)
        {
            return;
        }

        // Generate mapping extensions
        var source = GenerateMappingExtensions(mappingsToGenerate);
        context.AddSource("EnumMappingExtensions.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    [SuppressMessage("Meziantou.Analyzer", "MA0051:Method is too long", Justification = "OK")]
    private static List<EnumMappingInfo>? ExtractMappingInfo(
        INamedTypeSymbol enumSymbol,
        SourceProductionContext context)
    {
        var mappings = new List<EnumMappingInfo>();

        // Get all MapTo attributes
        var attributes = enumSymbol
            .GetAttributes()
            .Where(a => a.AttributeClass?.ToDisplayString() == FullAttributeName);

        foreach (var attribute in attributes)
        {
            if (attribute.ConstructorArguments.Length == 0)
            {
                continue;
            }

            var targetTypeValue = attribute.ConstructorArguments[0].Value;
            if (targetTypeValue is not INamedTypeSymbol targetType)
            {
                continue;
            }

            // Validate target type is an enum
            if (targetType.TypeKind != TypeKind.Enum)
            {
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        TargetTypeMustBeEnumDescriptor,
                        enumSymbol.Locations.First(),
                        targetType.Name));
                continue;
            }

            // Extract Bidirectional property
            var bidirectional = false;
            foreach (var namedArg in attribute.NamedArguments)
            {
                if (namedArg.Key == "Bidirectional")
                {
                    bidirectional = namedArg.Value.Value as bool? ?? false;
                    break;
                }
            }

            // Get enum value mappings
            var valueMappings = EnumMappingHelper.GetEnumValueMappings(enumSymbol, targetType);

            // Report warnings for unmapped values
            foreach (var mapping in valueMappings.Where(m => !m.IsMapped))
            {
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        UnmappedEnumValueDescriptor,
                        enumSymbol.Locations.First(),
                        enumSymbol.Name,
                        mapping.SourceValue,
                        targetType.Name));
            }

            mappings.Add(new EnumMappingInfo(
                SourceEnum: enumSymbol,
                TargetEnum: targetType,
                ValueMappings: valueMappings,
                Bidirectional: bidirectional));
        }

        return mappings.Count > 0 ? mappings : null;
    }

    private static string GenerateMappingExtensions(
        List<EnumMappingInfo> mappings)
    {
        var sb = new StringBuilder();
        var namespaces = new HashSet<string>(StringComparer.Ordinal);

        // Collect all namespaces
        foreach (var mapping in mappings)
        {
            namespaces.Add(mapping.SourceEnum.ContainingNamespace.ToDisplayString());
            namespaces.Add(mapping.TargetEnum.ContainingNamespace.ToDisplayString());
        }

        sb.AppendLineLf("// <auto-generated/>");
        sb.AppendLineLf("#nullable enable");
        sb.AppendLineLf();

        foreach (var ns in namespaces.OrderBy(x => x, StringComparer.Ordinal))
        {
            sb.AppendLineLf($"using {ns};");
        }

        sb.AppendLineLf();
        sb.AppendLineLf("namespace Atc.Mapping;");
        sb.AppendLineLf();
        sb.AppendLineLf("/// <summary>");
        sb.AppendLineLf("/// Extension methods for enum mapping.");
        sb.AppendLineLf("/// </summary>");
        sb.AppendLineLf("[global::System.CodeDom.Compiler.GeneratedCode(\"Atc.SourceGenerators.EnumMapping\", \"1.0.0\")]");
        sb.AppendLineLf("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
        sb.AppendLineLf("[global::System.Runtime.CompilerServices.CompilerGenerated]");
        sb.AppendLineLf("[global::System.Diagnostics.DebuggerNonUserCode]");
        sb.AppendLineLf("[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]");
        sb.AppendLineLf("public static class EnumMappingExtensions");
        sb.AppendLineLf("{");

        foreach (var mapping in mappings)
        {
            GenerateMappingMethod(sb, mapping);

            // Generate reverse mapping if bidirectional
            if (mapping.Bidirectional)
            {
                var reverseValueMappings = EnumMappingHelper.GetEnumValueMappings(
                    sourceEnum: mapping.TargetEnum,
                    targetEnum: mapping.SourceEnum);

                var reverseMapping = new EnumMappingInfo(
                    SourceEnum: mapping.TargetEnum,
                    TargetEnum: mapping.SourceEnum,
                    ValueMappings: reverseValueMappings,
                    Bidirectional: false); // Don't generate reverse of reverse

                GenerateMappingMethod(sb, reverseMapping);
            }
        }

        sb.AppendLineLf("}");

        return sb.ToString();
    }

    private static void GenerateMappingMethod(
        StringBuilder sb,
        EnumMappingInfo mapping)
    {
        var methodName = $"MapTo{mapping.TargetEnum.Name}";

        sb.AppendLineLf("    /// <summary>");
        sb.AppendLineLf($"    /// Maps <see cref=\"{mapping.SourceEnum.ToDisplayString()}\"/> to <see cref=\"{mapping.TargetEnum.ToDisplayString()}\"/>.");
        sb.AppendLineLf("    /// </summary>");
        sb.AppendLineLf($"    public static {mapping.TargetEnum.ToDisplayString()} {methodName}(");
        sb.AppendLineLf($"        this {mapping.SourceEnum.ToDisplayString()} source)");
        sb.AppendLineLf("        => source switch");
        sb.AppendLineLf("        {");

        // Generate switch cases
        foreach (var valueMapping in mapping.ValueMappings)
        {
            if (valueMapping.IsMapped &&
                valueMapping.TargetValue is not null)
            {
                sb.AppendLineLf($"            {mapping.SourceEnum.ToDisplayString()}.{valueMapping.SourceValue} => {mapping.TargetEnum.ToDisplayString()}.{valueMapping.TargetValue},");
            }
        }

        sb.AppendLineLf("            _ => throw new global::System.ArgumentOutOfRangeException(nameof(source), source, \"Unmapped enum value\"),");
        sb.AppendLineLf("        };");
        sb.AppendLineLf();
    }
}