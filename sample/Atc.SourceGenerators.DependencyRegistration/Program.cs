#pragma warning disable CA1031

Console.WriteLine("=== Atc.SourceGenerators Sample ===\n");

// Create service collection
var services = new ServiceCollection();

// Register all services decorated with [Registration] attribute from both assemblies
// These extension methods are generated by the source generator
services.AddDependencyRegistrationsFromDependencyRegistration();
services.AddDependencyRegistrationsFromDomain();

// Build service provider
var serviceProvider = services.BuildServiceProvider();

Console.WriteLine("1. Testing Scoped Service (IUserService -> UserService):");
using (var scope = serviceProvider.CreateScope())
{
    var userService = scope.ServiceProvider.GetRequiredService<IUserService>();
    userService.CreateUser("John Doe");
    userService.DeleteUser("Jane Smith");
}

Console.WriteLine("\n2. Testing Singleton Service (CacheService):");
var cache1 = serviceProvider.GetRequiredService<CacheService>();
var cache2 = serviceProvider.GetRequiredService<CacheService>();
cache1.Set("key1", "value1");
cache2.Set("key2", "value2");
Console.WriteLine($"Same instance: {ReferenceEquals(cache1, cache2)}");

Console.WriteLine("\n3. Testing Transient Service (LoggerService):");
var logger1 = serviceProvider.GetRequiredService<LoggerService>();
var logger2 = serviceProvider.GetRequiredService<LoggerService>();
logger1.Log("Message from logger 1");
logger2.Log("Message from logger 2");
Console.WriteLine($"Different instances: {!ReferenceEquals(logger1, logger2)}");

Console.WriteLine("\n4. Testing Service with AsSelf (EmailNotificationService):");

// Can be resolved as interface
var notificationService = serviceProvider.GetRequiredService<INotificationService>();
notificationService.Send("Hello via interface!");

// Can also be resolved as concrete type
var emailService = serviceProvider.GetRequiredService<EmailNotificationService>();
emailService.SendBulk(["Email 1", "Email 2", "Email 3"]);

Console.WriteLine($"\nSame instance: {ReferenceEquals(notificationService, emailService)}");

Console.WriteLine("\n5. Testing Generic Repository Pattern (IRepository<T> -> Repository<T>):");
using (var scope = serviceProvider.CreateScope())
{
    // Resolve IRepository<User>
    var userRepository = scope.ServiceProvider.GetRequiredService<IRepository<User>>();
    userRepository.Add(new User { Id = 1, Name = "John Doe", Email = "john@example.com" });
    userRepository.Add(new User { Id = 2, Name = "Jane Smith", Email = "jane@example.com" });

    var user = userRepository.GetById(1);
    Console.WriteLine($"Retrieved user: {user?.Name} ({user?.Email})");

    var allUsers = userRepository.GetAll();
    Console.WriteLine($"Total users: {allUsers.Count()}");

    // Resolve IRepository<Product>
    var productRepository = scope.ServiceProvider.GetRequiredService<IRepository<Product>>();
    productRepository.Add(new Product { Id = 1, Name = "Laptop", Price = 999.99m });
    productRepository.Add(new Product { Id = 2, Name = "Mouse", Price = 29.99m });

    var product = productRepository.GetById(1);
    Console.WriteLine($"Retrieved product: {product?.Name} (${product?.Price})");

    var allProducts = productRepository.GetAll();
    Console.WriteLine($"Total products: {allProducts.Count()}");

    // Verify different repository instances for different types
    Console.WriteLine($"\nDifferent repository types: {userRepository.GetType() != productRepository.GetType()}");
}

Console.WriteLine("\n6. Testing Keyed Services (IPaymentProcessor with different keys):");
using (var scope = serviceProvider.CreateScope())
{
    // Resolve payment processors by key
    var stripeProcessor = scope.ServiceProvider.GetRequiredKeyedService<IPaymentProcessor>("Stripe");
    var paypalProcessor = scope.ServiceProvider.GetRequiredKeyedService<IPaymentProcessor>("PayPal");
    var squareProcessor = scope.ServiceProvider.GetRequiredKeyedService<IPaymentProcessor>("Square");

    Console.WriteLine($"Resolved {stripeProcessor.ProviderName} processor");
    await stripeProcessor.ProcessPaymentAsync(100.50m, "USD");

    Console.WriteLine($"Resolved {paypalProcessor.ProviderName} processor");
    await paypalProcessor.ProcessPaymentAsync(75.25m, "EUR");

    Console.WriteLine($"Resolved {squareProcessor.ProviderName} processor");
    await squareProcessor.ProcessPaymentAsync(50.00m, "GBP");

    // Verify different instances
    Console.WriteLine($"\nDifferent processor types:");
    Console.WriteLine($"  Stripe != PayPal: {stripeProcessor.GetType() != paypalProcessor.GetType()}");
    Console.WriteLine($"  PayPal != Square: {paypalProcessor.GetType() != squareProcessor.GetType()}");
}

Console.WriteLine("\n7. Testing Factory Method Registration (IEmailSender -> EmailSender):");
using (var scope = serviceProvider.CreateScope())
{
    // Resolve email sender - this will call the factory method
    var emailSender = scope.ServiceProvider.GetRequiredService<IEmailSender>();

    // Send test email
    await emailSender.SendEmailAsync(
        "user@example.com",
        "Welcome to Factory Method Registration!",
        "This email was sent using a service created via factory method.");

    Console.WriteLine("\nFactory method registration allows custom initialization logic and dependency resolution.");
}

Console.WriteLine("\n8. Testing TryAdd Registration (ILogger -> DefaultLogger):");
using (var scope = serviceProvider.CreateScope())
{
    // The DefaultLogger is registered with TryAdd = true
    // This means it only registers if no other ILogger is already registered
    var logger = scope.ServiceProvider.GetRequiredService<ILogger>();
    logger.Log("This message is logged using the default logger.");
    logger.Log("TryAdd allows library authors to provide default implementations that can be overridden.");

    Console.WriteLine("\nNote: DefaultLogger uses TryAdd registration.");
    Console.WriteLine("If you register a custom ILogger BEFORE calling AddDependencyRegistrations,");
    Console.WriteLine("your implementation will be used instead of the default.");
}

Console.WriteLine("\n9. Assembly Scanning Filters:");
Console.WriteLine("This assembly uses [RegistrationFilter] attributes to exclude certain services:");
Console.WriteLine("  - ExcludeNamespaces: 'Atc.SourceGenerators.DependencyRegistration.Services.Internal'");
Console.WriteLine("  - ExcludePatterns: '*Mock*', '*Test*'");
Console.WriteLine("\nThe following services are excluded from automatic registration:");
Console.WriteLine("  - InternalUtility (excluded by namespace filter)");
Console.WriteLine("  - MockEmailService (excluded by pattern filter *Mock*)");
Console.WriteLine("\nTry resolving these services - they will NOT be available:");

try
{
    var mockService = serviceProvider.GetService<IMockEmailService>();
    Console.WriteLine($"  MockEmailService resolved: {mockService != null}");
}
catch
{
    Console.WriteLine("  MockEmailService: Not registered (as expected)");
}

Console.WriteLine("\n=== All tests completed successfully! ===");