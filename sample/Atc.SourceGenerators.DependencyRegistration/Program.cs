#pragma warning disable CA1031

Console.WriteLine("=== Atc.SourceGenerators Sample ===\n");

// Create service collection
var services = new ServiceCollection();

// Register all services decorated with [Registration] attribute from both assemblies
// These extension methods are generated by the source generator
services.AddDependencyRegistrationsFromDependencyRegistration();
services.AddDependencyRegistrationsFromDomain();

// Build service provider
var serviceProvider = services.BuildServiceProvider();

Console.WriteLine("1. Testing Scoped Service (IUserService -> UserService):");
using (var scope = serviceProvider.CreateScope())
{
    var userService = scope.ServiceProvider.GetRequiredService<IUserService>();
    userService.CreateUser("John Doe");
    userService.DeleteUser("Jane Smith");
}

Console.WriteLine("\n2. Testing Singleton Service (CacheService):");
var cache1 = serviceProvider.GetRequiredService<CacheService>();
var cache2 = serviceProvider.GetRequiredService<CacheService>();
cache1.Set("key1", "value1");
cache2.Set("key2", "value2");
Console.WriteLine($"Same instance: {ReferenceEquals(cache1, cache2)}");

Console.WriteLine("\n3. Testing Transient Service (LoggerService):");
var logger1 = serviceProvider.GetRequiredService<LoggerService>();
var logger2 = serviceProvider.GetRequiredService<LoggerService>();
logger1.Log("Message from logger 1");
logger2.Log("Message from logger 2");
Console.WriteLine($"Different instances: {!ReferenceEquals(logger1, logger2)}");

Console.WriteLine("\n4. Testing Service with AsSelf (EmailNotificationService):");

// Can be resolved as interface
var notificationService = serviceProvider.GetRequiredService<INotificationService>();
notificationService.Send("Hello via interface!");

// Can also be resolved as concrete type
var emailService = serviceProvider.GetRequiredService<EmailNotificationService>();
emailService.SendBulk(["Email 1", "Email 2", "Email 3"]);

Console.WriteLine($"\nSame instance: {ReferenceEquals(notificationService, emailService)}");

Console.WriteLine("\n5. Testing Generic Repository Pattern (IRepository<T> -> Repository<T>):");
using (var scope = serviceProvider.CreateScope())
{
    // Resolve IRepository<User>
    var userRepository = scope.ServiceProvider.GetRequiredService<IRepository<User>>();
    userRepository.Add(new User { Id = 1, Name = "John Doe", Email = "john@example.com" });
    userRepository.Add(new User { Id = 2, Name = "Jane Smith", Email = "jane@example.com" });

    var user = userRepository.GetById(1);
    Console.WriteLine($"Retrieved user: {user?.Name} ({user?.Email})");

    var allUsers = userRepository.GetAll();
    Console.WriteLine($"Total users: {allUsers.Count()}");

    // Resolve IRepository<Product>
    var productRepository = scope.ServiceProvider.GetRequiredService<IRepository<Product>>();
    productRepository.Add(new Product { Id = 1, Name = "Laptop", Price = 999.99m });
    productRepository.Add(new Product { Id = 2, Name = "Mouse", Price = 29.99m });

    var product = productRepository.GetById(1);
    Console.WriteLine($"Retrieved product: {product?.Name} (${product?.Price})");

    var allProducts = productRepository.GetAll();
    Console.WriteLine($"Total products: {allProducts.Count()}");

    // Verify different repository instances for different types
    Console.WriteLine($"\nDifferent repository types: {userRepository.GetType() != productRepository.GetType()}");
}

Console.WriteLine("\n6. Testing Keyed Services (IPaymentProcessor with different keys):");
using (var scope = serviceProvider.CreateScope())
{
    // Resolve payment processors by key
    var stripeProcessor = scope.ServiceProvider.GetRequiredKeyedService<IPaymentProcessor>("Stripe");
    var paypalProcessor = scope.ServiceProvider.GetRequiredKeyedService<IPaymentProcessor>("PayPal");
    var squareProcessor = scope.ServiceProvider.GetRequiredKeyedService<IPaymentProcessor>("Square");

    Console.WriteLine($"Resolved {stripeProcessor.ProviderName} processor");
    await stripeProcessor.ProcessPaymentAsync(100.50m, "USD");

    Console.WriteLine($"Resolved {paypalProcessor.ProviderName} processor");
    await paypalProcessor.ProcessPaymentAsync(75.25m, "EUR");

    Console.WriteLine($"Resolved {squareProcessor.ProviderName} processor");
    await squareProcessor.ProcessPaymentAsync(50.00m, "GBP");

    // Verify different instances
    Console.WriteLine($"\nDifferent processor types:");
    Console.WriteLine($"  Stripe != PayPal: {stripeProcessor.GetType() != paypalProcessor.GetType()}");
    Console.WriteLine($"  PayPal != Square: {paypalProcessor.GetType() != squareProcessor.GetType()}");
}

Console.WriteLine("\n7. Testing Factory Method Registration (IEmailSender -> EmailSender):");
using (var scope = serviceProvider.CreateScope())
{
    // Resolve email sender - this will call the factory method
    var emailSender = scope.ServiceProvider.GetRequiredService<IEmailSender>();

    // Send test email
    await emailSender.SendEmailAsync(
        "user@example.com",
        "Welcome to Factory Method Registration!",
        "This email was sent using a service created via factory method.");

    Console.WriteLine("\nFactory method registration allows custom initialization logic and dependency resolution.");
}

Console.WriteLine("\n8. Testing TryAdd Registration (ILogger -> DefaultLogger):");
using (var scope = serviceProvider.CreateScope())
{
    // The DefaultLogger is registered with TryAdd = true
    // This means it only registers if no other ILogger is already registered
    var logger = scope.ServiceProvider.GetRequiredService<ILogger>();
    logger.Log("This message is logged using the default logger.");
    logger.Log("TryAdd allows library authors to provide default implementations that can be overridden.");

    Console.WriteLine("\nNote: DefaultLogger uses TryAdd registration.");
    Console.WriteLine("If you register a custom ILogger BEFORE calling AddDependencyRegistrations,");
    Console.WriteLine("your implementation will be used instead of the default.");
}

Console.WriteLine("\n9. Assembly Scanning Filters:");
Console.WriteLine("This assembly uses [RegistrationFilter] attributes to exclude certain services:");
Console.WriteLine("  - ExcludeNamespaces: 'Atc.SourceGenerators.DependencyRegistration.Services.Internal'");
Console.WriteLine("  - ExcludePatterns: '*Mock*', '*Test*'");
Console.WriteLine("\nThe following services are excluded from automatic registration:");
Console.WriteLine("  - InternalUtility (excluded by namespace filter)");
Console.WriteLine("  - MockEmailService (excluded by pattern filter *Mock*)");
Console.WriteLine("\nTry resolving these services - they will NOT be available:");

try
{
    var mockService = serviceProvider.GetService<IMockEmailService>();
    Console.WriteLine($"  MockEmailService resolved: {mockService != null}");
}
catch
{
    Console.WriteLine("  MockEmailService: Not registered (as expected)");
}

Console.WriteLine("\n10. Runtime Filtering:");
Console.WriteLine("Runtime filtering allows excluding specific services when calling the registration methods.");
Console.WriteLine("This is useful when different applications need different subsets of services from a shared library.\n");

// Example 1: Exclude by type
Console.WriteLine("Example - Creating a new service collection with runtime type exclusion:");
var filteredServices = new ServiceCollection();
filteredServices.AddDependencyRegistrationsFromDependencyRegistration(
    excludedTypes: new[] { typeof(CacheService) });
var filteredProvider = filteredServices.BuildServiceProvider();

try
{
    var cache = filteredProvider.GetRequiredService<CacheService>();
    Console.WriteLine("  ERROR: CacheService should have been excluded!");
}
catch (InvalidOperationException)
{
    Console.WriteLine("  ✓ CacheService successfully excluded by runtime type filter");
}

// Example 2: Exclude by namespace
var filteredServices2 = new ServiceCollection();
filteredServices2.AddDependencyRegistrationsFromDependencyRegistration(
    excludedNamespaces: new[] { "Atc.SourceGenerators.DependencyRegistration.Services.Internal" });
var filteredProvider2 = filteredServices2.BuildServiceProvider();

try
{
    var internalService = filteredProvider2.GetService<IInternalUtility>();
    Console.WriteLine($"  ✓ InternalUtility excluded by runtime namespace filter: {internalService == null}");
}
catch
{
    Console.WriteLine("  ✓ InternalUtility excluded by runtime namespace filter");
}

// Example 3: Exclude by pattern
var filteredServices3 = new ServiceCollection();
filteredServices3.AddDependencyRegistrationsFromDependencyRegistration(
    excludedPatterns: new[] { "*Logger*" });
var filteredProvider3 = filteredServices3.BuildServiceProvider();

try
{
    var logger = filteredProvider3.GetRequiredService<LoggerService>();
    Console.WriteLine("  ERROR: LoggerService should have been excluded!");
}
catch (InvalidOperationException)
{
    Console.WriteLine("  ✓ LoggerService successfully excluded by runtime pattern filter (*Logger*)");
}

Console.WriteLine("\nRuntime filtering complements compile-time filtering:");
Console.WriteLine("  - Compile-time (assembly-level) filters exclude from ALL registrations");
Console.WriteLine("  - Runtime filters allow selective exclusion per application/scenario");

Console.WriteLine("\n11. Decorator Pattern:");
Console.WriteLine("Decorators wrap existing services to add cross-cutting concerns like logging, caching, validation, etc.");
Console.WriteLine("The decorator is automatically applied when resolving the service.\n");

using (var scope = serviceProvider.CreateScope())
{
    var orderService = scope.ServiceProvider.GetRequiredService<IOrderService>();
    await orderService.PlaceOrderAsync("ORDER-12345");

    Console.WriteLine("\n✓ Decorator pattern applied successfully!");
    Console.WriteLine("  The LoggingOrderServiceDecorator wraps OrderService, adding logging before/after the operation.");
}

Console.WriteLine("\n12. Testing Instance Registration (IAppConfiguration -> AppConfiguration):");
Console.WriteLine("Instance registration allows registering pre-created singleton instances.");
Console.WriteLine("This is useful for configuration objects that are initialized at startup.\n");

using (var scope = serviceProvider.CreateScope())
{
    var config1 = scope.ServiceProvider.GetRequiredService<IAppConfiguration>();
    var config2 = serviceProvider.GetRequiredService<IAppConfiguration>();

    Console.WriteLine($"Application Name: {config1.ApplicationName}");
    Console.WriteLine($"Environment: {config1.Environment}");
    Console.WriteLine($"Max Connections: {config1.MaxConnections}");
    Console.WriteLine($"Debug Mode: {config1.IsDebugMode}");

    var connectionString = config1.GetValue("ConnectionString");
    Console.WriteLine($"Connection String: {connectionString}");

    Console.WriteLine($"\nSame instance (singleton): {ReferenceEquals(config1, config2)}");
    Console.WriteLine($"Instance is AppConfiguration.DefaultInstance: {ReferenceEquals(config1, AppConfiguration.DefaultInstance)}");

    Console.WriteLine("\n✓ Instance registration ensures a pre-created instance is used by all consumers.");
    Console.WriteLine("  This pattern is ideal for immutable configuration objects.");
}

Console.WriteLine("\n=== All tests completed successfully! ===");